{"version":3,"file":"asyncQueue.js","sourceRoot":"../../..","sources":["components/util/asyncQueue/asyncQueue.ts"],"sourcesContent":["/**\r\n * 表示一个异步任务队列。\r\n * @example\r\n * var deferred = new AsyncQueue();\r\n * deferred.then(function () {      // 添加一个异步任务。\r\n *     deferred.suspend();          // 挂起等待。\r\n *     setTimeout(function () {     // 模拟异步执行。\r\n *         deferred.resume(1);      // 恢复执行。\r\n *     }, 2000);\r\n * });\r\n *\r\n * deferred.then(function (data) {  // 添加一个同步任务。\r\n *     console.log(\"所有异步操作完成。返回的数据：\" + data);\r\n * });\r\n */\r\nexport default class AsyncQueue {\r\n\r\n    /**\r\n     * 存储所有异步任务队列。\r\n     */\r\n    private _queue: Function[] = [];\r\n\r\n    /**\r\n     * 存储当前队列正在等待的异步任务。\r\n     */\r\n    private _waiting: Abortable | null | true;\r\n\r\n    /**\r\n     * 判断当前队列是否已被阻止。\r\n     */\r\n    get suspended() { return !!this._waiting; }\r\n\r\n    /**\r\n     * 存储传递给下一个异步任务的参数列表。\r\n     */\r\n    private _data: any;\r\n\r\n    /**\r\n     * 执行当前队列的第一个异步任务。\r\n     */\r\n    private _progress() {\r\n\r\n        // 不再等待任务对象。\r\n        this._waiting = null;\r\n\r\n        // 执行第一个回调函数。\r\n        const cb = this._queue.shift();\r\n        if (cb) {\r\n            cb(this._data);\r\n\r\n            // 如果当前对象未被挂起，继续执行下一个任务。\r\n            if (!this._waiting) this._progress();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 挂起异步等待操作。\r\n     * @param abortable 引发挂起的对象。将调用其 `abort()` 方法恢复挂起。\r\n     * @example new AsyncQueue().suspend()\r\n     */\r\n    suspend(abortable?: Abortable) {\r\n        this._waiting = abortable || true;\r\n    }\r\n\r\n    /**\r\n     * 通知当前异步任务已经完成，并继续执行下一个任务。\r\n     * @param datas 传递给下个异步任务的数据。\r\n     * @example new AsyncQueue().resume()\r\n     */\r\n    resume(data: any) {\r\n\r\n        // 更新当前的回调数据。\r\n        this._data = data;\r\n\r\n        // 继续执行下一个任务。\r\n        this._progress();\r\n    }\r\n\r\n    /**\r\n     * 添加一个同步或异步任务。\r\n     * @param callback 要添加的任务函数。函数的参数为上个异步调用传递的数据。\r\n     * 如果是异步函数，则函数内部必须调用 @suspend 挂起队列，并在异步完成后调用 @resume 恢复队列。\r\n     * 函数应该返回一个包含 `abort` 方法的对象，以便于终止此异步操作。\r\n     *\r\n     * @param link = \"wait\" 定义正在执行其它异步任务时，@fn 的操作。\r\n     *\r\n     * 值        | 意义\r\n     * ----------|--------------------------------------------\r\n     * wait(默认)| 等待之前的所有异步任务都完成后再执行当前任务。\r\n     * abort     | 立即终止正在执行的异步任务并撤销等待的剩余任务，然后立即执行当前任务。\r\n     * replace   | 立即终止正在执行的异步任务并立即执行当前任务，然后继续执行其它正在等待的异步任务。\r\n     * insert    | 等待正在执行的异步任务完成后执行当前任务，然后继续执行其它正在等待的异步任务。\r\n     * cancel    | 取消当前任务。\r\n     *\r\n     * @example new AsyncQueue().then(function(){ });\r\n     */\r\n    then(callback: (data: any) => void, link: \"wait\" | \"abort\" | \"insert\" | \"replace\" | \"cancel\" = \"wait\") {\r\n        if (this._queue.length) {\r\n            switch (link) {\r\n\r\n                // 终止之前的所有任务，重新开始队列。\r\n                case \"abort\":\r\n                    this._queue.length = 1;\r\n                    this._queue[0] = callback;\r\n                    this.skip();\r\n                    break;\r\n\r\n                // 插入队伍前面，等待当前任务完成后执行。\r\n                case \"insert\":\r\n                    this._queue.splice(1, 0, callback);\r\n                    break;\r\n\r\n                // 立即终止正在执行的任务，并替换为任务。\r\n                case \"replace\":\r\n                    this._queue.splice(1, 0, callback);\r\n                    this.skip();\r\n                // fall through\r\n                case \"cancel\":\r\n                    break;\r\n\r\n                // 插入队伍后面，等待当前任务完成后执行。\r\n                default:\r\n                    this._queue.push(callback);\r\n\r\n            }\r\n        } else {\r\n            this._queue.push(callback);\r\n            if (!this._waiting) {\r\n                this._progress();\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 终止当前正在执行的异步任务并执行后续任务。\r\n     * @example new AsyncQueue().abort();\r\n     */\r\n    skip() {\r\n        this._waiting && (this._waiting as Abortable).abort ? (this._waiting as Abortable).abort() : this._progress();\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * 表示一个可终止的异步操作。\r\n */\r\nexport interface Abortable {\r\n\r\n    /**\r\n     * 终止当前异步操作。\r\n     */\r\n    abort(): void;\r\n\r\n}\r\n"],"mappings":";;IAAA;;;;;;;;;;;;;;OAcG;IACH;QAAA;YAEI;;eAEG;YACK,WAAM,GAAe,EAAE,CAAC;QA2HpC,CAAC;QApHG;;WAEG;QACH,IAAI,SAAS,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAO3C;;WAEG;QACK,SAAS;YAEb,YAAY;YACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YAErB,aAAa;YACb,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YAC/B,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACL,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAEf,wBAAwB;gBACxB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;oBAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACzC,CAAC;QACL,CAAC;QAED;;;;WAIG;QACH,OAAO,CAAC,SAAqB;YACzB,IAAI,CAAC,QAAQ,GAAG,SAAS,IAAI,IAAI,CAAC;QACtC,CAAC;QAED;;;;WAIG;QACH,MAAM,CAAC,IAAS;YAEZ,aAAa;YACb,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;YAElB,aAAa;YACb,IAAI,CAAC,SAAS,EAAE,CAAC;QACrB,CAAC;QAED;;;;;;;;;;;;;;;;;WAiBG;QACH,IAAI,CAAC,QAA6B,EAAE,OAA2D,MAAM;YACjG,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;gBACrB,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;oBAEX,oBAAoB;oBACpB,KAAK,OAAO;wBACR,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;wBACvB,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;wBAC1B,IAAI,CAAC,IAAI,EAAE,CAAC;wBACZ,KAAK,CAAC;oBAEV,sBAAsB;oBACtB,KAAK,QAAQ;wBACT,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;wBACnC,KAAK,CAAC;oBAEV,sBAAsB;oBACtB,KAAK,SAAS;wBACV,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;wBACnC,IAAI,CAAC,IAAI,EAAE,CAAC;oBAChB,eAAe;oBACf,KAAK,QAAQ;wBACT,KAAK,CAAC;oBAEV,sBAAsB;oBACtB;wBACI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAEnC,CAAC;YACL,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACjB,IAAI,CAAC,SAAS,EAAE,CAAC;gBACrB,CAAC;YACL,CAAC;YACD,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;QAED;;;WAGG;QACH,IAAI;YACA,IAAI,CAAC,QAAQ,IAAK,IAAI,CAAC,QAAsB,CAAC,KAAK,GAAI,IAAI,CAAC,QAAsB,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAC9G,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC;KAEJ;IAhID,6BAgIC"}