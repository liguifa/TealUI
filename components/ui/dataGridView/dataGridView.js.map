{"version":3,"file":"dataGridView.js","sourceRoot":"../../..","sources":["components/ui/dataGridView/dataGridView.tsx"],"sourcesContent":["import * as dom from \"uux/dom;\r\nimport Control, { VNode, bind } from \"ui/control\";\r\nimport \"typo/table/table.scss\";\r\nimport \"./dataGridView.scss\";\r\n\r\n/**\r\n * 表示一个表格视图。\r\n */\r\nexport default class DataGridView extends Control {\r\n\r\n    protected render() {\r\n        return <div class=\"x-datagridview\"></div>;\r\n    }\r\n\r\n}\r\n/**\r\n * @fileOverview 数据表视图\r\n * @author xuld <xuld@vip.qq.com>\r\n */\r\nimport * as dom from \"dom\";\r\nimport Control from \"control\";\r\nimport TextBox from \"textBox\";\r\n\r\n/**\r\n * 表示一个数据表视图。\r\n */\r\nexport default class DataGridView extends Control {\r\n\r\n    // #region 表格主体\r\n\r\n    /**\r\n     * 获取当前控件的模板。\r\n     */\r\n    protected tpl = `<table class=\"x-table\"><thead><tr/></thead><tbody/></table>`;\r\n\r\n    /**\r\n\t * 当被子类重写时，负责初始化当前控件。\r\n\t */\r\n    protected init() {\r\n        const me = this;\r\n        dom.on(this.header, \"click\", \">*\", function(e) { me.onHeaderClick(this, e); });\r\n        dom.on(this.body, \"dblclick\", \">tr\", function(e) { me.onCellDblClick(this, e); });\r\n    }\r\n\r\n    protected onHeaderClick(header: HTMLTableCellElement, e: Event) {\r\n        if (this.sortable !== false) {\r\n            const sortColumnIndex = dom.index(header);\r\n            if (this.sortColumnIndex === sortColumnIndex) {\r\n                this.sortDesc = !this.sortDesc;\r\n            } else {\r\n                this.sortColumnIndex = sortColumnIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected onCellDblClick(row: HTMLTableRowElement, e: Event) {\r\n        this.toggleEdit(row);\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region 表头和列\r\n\r\n    /**\r\n     * 获取表头。\r\n     */\r\n    get head() { return dom.first<HTMLTableSectionElement>(this.elem, \"thead\"); }\r\n\r\n    /**\r\n     * 获取表头行。\r\n     */\r\n    get header() { return dom.last<HTMLTableRowElement>(this.head, \"tr\"); }\r\n\r\n    /**\r\n     * 获取列数。\r\n     */\r\n    get columnCount() { return this.header.cells.length; }\r\n\r\n    /**\r\n     * 获取所有列的信息。\r\n     */\r\n    get columns() {\r\n        const result: ColumnInfo<any>[] = [];\r\n        const columnCount = this.columnCount;\r\n        for (let i = 0; i < columnCount; i++) {\r\n            result[i] = this.getColumn(i);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 设置所有列的信息。\r\n     */\r\n    set columns(value) {\r\n        this.spliceColumn(0, this.columnCount, ...value);\r\n    }\r\n\r\n    /**\r\n     * 获取指定列的信息。\r\n     * @param index 相关的列号。\r\n     * @return 返回列信息。如果列不存在则返回 undefined。\r\n     */\r\n    getColumn<T>(index: number) {\r\n        const cell: DataGridHeaderCell = this.header.cells[index];\r\n        if (cell) {\r\n            return cell.data || (cell.data = {\r\n                name: dom.getHtml(cell),\r\n                title: cell.title || dom.getText(cell),\r\n                hidden: dom.isHidden(cell)\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置指定列的信息。\r\n     * @param index 相关的列号。如果列超出索引则自动追加。\r\n     * @param value 相关的列信息。设置为 null 表示删除。\r\n     */\r\n    setColumn<T>(index: number, value: ColumnInfo<T>) {\r\n        this.spliceColumn(index, 1, value);\r\n    }\r\n\r\n    /**\r\n     * 插入一个列。\r\n     * @param index 插入的列号。\r\n     * @param value 相关的列信息。\r\n     */\r\n    insertColumn<T>(index: number, value?: ColumnInfo<T>) {\r\n        this.spliceColumn(index, 0, value);\r\n    }\r\n\r\n    /**\r\n     * 在末尾添加一个列。\r\n     * @param value 相关的列信息。\r\n     */\r\n    addColumn<T>(value?: ColumnInfo<T>) {\r\n        this.insertColumn(this.columnCount, value);\r\n    }\r\n\r\n    /**\r\n     * 移除指定的列。\r\n     * @param index 移除的列号。\r\n     */\r\n    removeColumn(index: number) {\r\n        this.spliceColumn(index, 1);\r\n    }\r\n\r\n    /**\r\n     * 交换两个列。\r\n     * @param x 交换的第一个列。\r\n     * @param y 交换的第二个列。\r\n     */\r\n    swapColumn(x: number, y: number) {\r\n        console.assert(x >= 0 && x < this.columnCount);\r\n        console.assert(y >= 0 && y < this.columnCount);\r\n        if (x === y) {\r\n            return;\r\n        }\r\n        if (x > y) {\r\n            const t = x;\r\n            x = y;\r\n            y = t;\r\n        }\r\n        const header = this.header;\r\n        const rows = (<HTMLTableElement>this.elem).rows;\r\n        for (let i = 0, row: HTMLTableRowElement; row = rows[i]; i++) {\r\n            const cellX = row.cells[x];\r\n            dom.before(cellX, row.cells[y]);\r\n            dom.after(row.cells[y], cellX);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 新增或删除列信息。\r\n     * @param index 新增或删除的位置。\r\n     * @param removeCount 删除的列数。\r\n     * @param inserts 插入的列。\r\n     */\r\n    spliceColumn(index: number, removeCount: number, ...inserts: ColumnInfo<any>[]) {\r\n        console.assert(index >= 0 && index <= this.columnCount);\r\n        console.assert(removeCount >= 0 && removeCount <= this.columnCount);\r\n\r\n        const header = this.header;\r\n        const rows = (<HTMLTableElement>this.elem).rows;\r\n        let needRefilter: boolean;\r\n        let needResort: boolean;\r\n        let i = 0;\r\n\r\n        // 更新。\r\n        for (const updateCount = Math.min(removeCount, inserts.length); i < updateCount; i++) {\r\n            const columnIndex = index + i;\r\n            const oldColumn = this.getColumn(columnIndex);\r\n            const newColumn = inserts[i];\r\n            const headerCell: DataGridHeaderCell = header.cells[columnIndex];\r\n            if (newColumn.name) {\r\n                dom.setHtml(headerCell, newColumn.name);\r\n            }\r\n            if (newColumn.name || newColumn.title) {\r\n                headerCell.title = newColumn.title || dom.getText(headerCell);\r\n            }\r\n            if (newColumn.hidden != undefined || newColumn.format) {\r\n                for (let i = 0, row: HTMLTableRowElement; row = rows[i]; i++) {\r\n                    const cell = row.cells[columnIndex];\r\n                    if (cell) {\r\n                        if (newColumn.hidden != undefined) {\r\n                            dom.toggle(cell, \"width\", null, this.duration, null, !newColumn.hidden);\r\n                        }\r\n                        if (row !== header && newColumn.format) {\r\n                            this.setDataOf(cell, this.getDataOf(cell, oldColumn), newColumn);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (newColumn.filter !== oldColumn.filter || newColumn.parse !== oldColumn.parse && (newColumn.filter || oldColumn.filter)) {\r\n                needRefilter = true;\r\n            }\r\n            if (columnIndex === this.sortColumnIndex && (newColumn.sort !== oldColumn.sort || newColumn.parse !== oldColumn.parse)) {\r\n                needResort = true;\r\n            }\r\n            headerCell.data = Object.assign(oldColumn, newColumn);\r\n        }\r\n\r\n        // 新增。\r\n        for (; i < inserts.length; i++) {\r\n            const columnIndex = index + i;\r\n            const newColumn = Object.assign({}, inserts[i]);\r\n            for (let i = 0, row: HTMLTableRowElement; row = rows[i]; i++) {\r\n                const html = row.parentNode.nodeName === \"THEAD\" ? \"<th/>\" : \"<td/>\";\r\n                const oldCell = <DataGridCell>row.cells[columnIndex];\r\n                let newCell: typeof oldCell;\r\n                if (oldCell) {\r\n                    newCell = <DataGridCell>dom.before(oldCell, html);\r\n                } else {\r\n                    while (!(newCell = row.cells[columnIndex])) {\r\n                        dom.append(row, html);\r\n                    }\r\n                }\r\n                if (newColumn.hidden) {\r\n                    dom.hide(newCell);\r\n                }\r\n                if (row === header) {\r\n                    if (newColumn.name) {\r\n                        dom.setHtml(newCell, newColumn.name);\r\n                    }\r\n                    if (newColumn.name || newColumn.title) {\r\n                        newCell.title = newColumn.title || dom.getText(newCell);\r\n                    }\r\n                    (<DataGridHeaderCell>newCell).data = newColumn;\r\n                } else {\r\n                    if (newColumn.filter && newColumn.filter(this.getDataOf(newCell, newColumn), newCell) === false) {\r\n                        dom.hide(row);\r\n                    }\r\n                    if (this.getEditing(newCell)) {\r\n                        this.setEditing(newCell, true, newColumn);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 删除。\r\n        for (; i < removeCount; i++) {\r\n            const columnIndex = index + i;\r\n            for (let i = 0, row: HTMLTableRowElement; row = rows[i]; i++) {\r\n                dom.remove(row.cells[columnIndex]);\r\n            }\r\n            if (this.getColumn(columnIndex).filter) {\r\n                needRefilter = true;\r\n            }\r\n        }\r\n\r\n        // 重新过滤。\r\n        if (needRefilter) {\r\n            for (let i = 0, row: HTMLTableRowElement; row = rows[i]; i++) {\r\n                if (row !== header) {\r\n                    let show = true;\r\n                    for (let i = 0, cell: HTMLTableCellElement; cell = row.cells[i]; i++) {\r\n                        const column = this.getColumn(i);\r\n                        if (column.filter && column.filter(this.getDataOf(cell, column), cell) === false) {\r\n                            show = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    this.toggleRow(row, show);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 重新排序。\r\n        if (needResort) {\r\n            this.sortByColumn(this.sortColumnIndex, this.sortDesc);\r\n        }\r\n\r\n        this.emit(\"columnchange\", removeCount, inserts);\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region 主体数据\r\n\r\n    /**\r\n     * 获取主体部分。\r\n     */\r\n    get body() { return dom.first(this.elem, \"tbody\"); }\r\n\r\n    /**\r\n     * 获取总行数。\r\n     */\r\n    get rowCount() { return this.rows.length; }\r\n\r\n    /**\r\n     * 获取所有行。\r\n     */\r\n    get rows() { return dom.query<HTMLTableRowElement>(\">tr\", this.body); }\r\n\r\n    /**\r\n     * 设置所有行。\r\n     */\r\n    set rows(value) {\r\n        Array.prototype.forEach.call(this.rows, dom.remove);\r\n        if (value) {\r\n            Array.prototype.forEach.call(value, row => dom.append(this.body, row));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取指定行的数据。\r\n     * @param index 相关的行号。\r\n     * @return 返回行数据。如果列不存在则返回 undefined。\r\n     */\r\n    getRow<T>(index: number) {\r\n        const row = this.rows[index];\r\n        if (row) {\r\n            const result = [];\r\n            for (let i = 0, cell: DataGridCell; cell = row.cells[i]; i++) {\r\n                result.push(this.getDataOf(cell));\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置指定列的信息。\r\n     * @param index 相关的列号。如果列超出索引则自动追加。\r\n     * @param value 相关的列信息。设置为 null 表示删除。\r\n     */\r\n    setRow(index: number, value: any[]) {\r\n        this.spliceRow(index, 1, value);\r\n    }\r\n\r\n    /**\r\n     * 插入一个列。\r\n     * @param index 插入的列号。\r\n     * @param value 相关的列信息。\r\n     */\r\n    insertRow(index: number, value?: any[]) {\r\n        this.spliceRow(index, 0, value || []);\r\n        return this.rows[index];\r\n    }\r\n\r\n    /**\r\n     * 在末尾添加一个列。\r\n     * @param value 相关的列信息。\r\n     * @return 返回新增的行号。\r\n     */\r\n    addRow(value?: any[]) {\r\n        return this.insertRow(this.rowCount, value);\r\n    }\r\n\r\n    /**\r\n     * 移除指定的列。\r\n     * @param index 移除的列号。\r\n     * @return 返回删除的行。\r\n     */\r\n    removeRow(index: number) {\r\n        const row = this.rows[index];\r\n        this.spliceRow(index, 1);\r\n        return row;\r\n    }\r\n\r\n    /**\r\n     * 新增或删除行。\r\n     * @param index 新增或删除的位置。\r\n     * @param removeCount 删除的行数。\r\n     * @param inserts 插入的行。\r\n     */\r\n    spliceRow(index: number, removeCount: number, ...inserts: any[][]) {\r\n        console.assert(index >= 0 && index <= this.rowCount);\r\n        console.assert(removeCount >= 0 && removeCount <= this.rowCount);\r\n        const rows = this.rows;\r\n        const columnCount = this.columnCount;\r\n        for (let i = 0; i < inserts.length; i++) {\r\n            const refRow = rows[index + i];\r\n            const row = refRow ? dom.before(refRow, \"<tr/>\") : dom.append(this.body, \"<tr/>\");\r\n            for (let j = 0; j < columnCount; j++) {\r\n                const cell = <DataGridCell>dom.append(row, \"<td/>\");\r\n                if (j < inserts[i].length) {\r\n                    this.setDataOf(cell, inserts[i][j]);\r\n                }\r\n            }\r\n        }\r\n        while (removeCount-- > 0) {\r\n            dom.remove(rows[index + removeCount]);\r\n        }\r\n        this.emit(\"rowchange\", index, removeCount, inserts);\r\n    }\r\n\r\n    /**\r\n     * 切换是否显示或隐藏行。\r\n     * @param row 相关的行号。\r\n     * @param value 是否隐藏。\r\n     */\r\n    toggleRow(row: HTMLTableRowElement | number, value?: boolean) {\r\n        if (typeof row === \"number\") row = this.rows[row];\r\n        dom.toggle(row, \"height\", null, this.duration, null, value);\r\n        for (let i = 0, cell: HTMLTableCellElement; cell = row.cells[i]; i++) {\r\n            dom.toggle(cell, \"height\", null, this.duration, null, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 显示行。\r\n     * @param row 相关的行号。\r\n     * @param value 是否隐藏。\r\n     */\r\n    showRow(row: HTMLTableRowElement | number, value?: boolean) {\r\n        this.toggleRow(row, true);\r\n    }\r\n\r\n    /**\r\n     * 隐藏行。\r\n     * @param row 相关的行号。\r\n     * @param value 是否隐藏。\r\n     */\r\n    hideRow(row: HTMLTableRowElement | number, value?: boolean) {\r\n        this.toggleRow(row, false);\r\n    }\r\n\r\n    /**\r\n     * 设置当前表格的数据源。\r\n     */\r\n    get data() {\r\n        const result: any[][] = [];\r\n        const rowCount = this.rowCount;\r\n        for (let i = 0; i < rowCount; i++) {\r\n            result.push(this.getRow(i));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 设置当前表格的数据源。\r\n     */\r\n    set data(value) {\r\n        this.spliceRow(0, this.rowCount, ...(value || []));\r\n    }\r\n\r\n    /**\r\n     * 获取指定单元格的数据。\r\n     * @param row 相关的行号。\r\n     * @param column 相关的列号。\r\n     * @return 返回绑定的值。如果单元格不存在则返回 undefined。\r\n     */\r\n    getData(row: number, column: number) {\r\n        const rowElem = this.rows[row];\r\n        const cell = rowElem && rowElem.cells[column];\r\n        return cell && this.getDataOf(cell);\r\n    }\r\n\r\n    /**\r\n     * 获取指定单元格的数据。如果单元格不存在则自动插入。\r\n     * @param row 相关的行号。\r\n     * @param column 相关的列号。\r\n     * @param value 要设置的值。\r\n     */\r\n    setData(row: number, column: number, value: any) {\r\n        console.assert(row >= 0 && row < this.rowCount);\r\n        console.assert(column >= 0 && column < this.rows[row].cells.length);\r\n        this.setDataOf(this.rows[row].cells[column], value);\r\n    }\r\n\r\n    /**\r\n     * 获取指定单元格的数据。\r\n     * @param cell 相关的单元格。\r\n     * @param column 使用的列信息。\r\n     * @return 返回绑定的值。\r\n     */\r\n    getDataOf(cell: DataGridCell, column?: ColumnInfo<any>) {\r\n        if (cell.editor) {\r\n            return cell.editor.value;\r\n        }\r\n        if (column === undefined) column = this.getColumn(cell.cellIndex);\r\n        const html = dom.getHtml(cell);\r\n        return column && column.parse ? column.parse(html, cell) : html;\r\n    }\r\n\r\n    /**\r\n     * 设置指定单元格的数据。\r\n     * @param cell 相关的单元格。\r\n     * @param value 相关的数据。\r\n     * @param column 使用的列信息。\r\n     */\r\n    setDataOf(cell: DataGridCell, value: any, column?: ColumnInfo<any>) {\r\n        if (cell.editor) {\r\n            cell.editor.value = value;\r\n            return;\r\n        }\r\n        if (column === undefined) column = this.getColumn(cell.cellIndex);\r\n        if (column && column.format) {\r\n            value = column.format(value, cell);\r\n        }\r\n        if (value !== undefined) {\r\n            dom.setHtml(cell, value);\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region 排序\r\n\r\n    /**\r\n     * 获取当前是否允许排序。\r\n     */\r\n    sortable: boolean;\r\n\r\n    /**\r\n     * 获取当前排序的列。\r\n     */\r\n    get sortColumn() { return dom.find<HTMLTableCellElement>(\">.x-table-sort\", this.header); }\r\n\r\n    /**\r\n     * 获取当前排序的列号。\r\n     */\r\n    get sortColumnIndex() {\r\n        const sortColumn = this.sortColumn;\r\n        return sortColumn ? sortColumn.cellIndex : -1;\r\n    }\r\n\r\n    /**\r\n     * 设置当前排序的列号。\r\n     */\r\n    set sortColumnIndex(value) {\r\n        console.assert(value >= 0 && value < this.columnCount);\r\n        if (this.sortable === false) {\r\n            return;\r\n        }\r\n        const column = this.getColumn(value);\r\n        if (column && column.sortable === false) {\r\n            return;\r\n        }\r\n        const sortColumn = this.sortColumn;\r\n        if (sortColumn) {\r\n            dom.removeClass(sortColumn, \"x-table-sort-desc\");\r\n            dom.removeClass(sortColumn, \"x-table-sort\");\r\n        }\r\n        dom.addClass(this.header.cells[value], \"x-table-sort\");\r\n        this.sortByColumn(value, false);\r\n    }\r\n\r\n    /**\r\n     * 获取当前是否倒序。\r\n     */\r\n    get sortDesc() {\r\n        const sortColumn = this.sortColumn;\r\n        return sortColumn && dom.match(sortColumn, \".x-table-sort-desc\");\r\n    }\r\n\r\n    /**\r\n     * 设置当前是否倒序。\r\n     */\r\n    set sortDesc(value) {\r\n        const sortColumn = this.sortColumn;\r\n        if (sortColumn) {\r\n            dom.toggleClass(sortColumn, \"x-table-sort-desc\", value);\r\n            const columnIndex = dom.index(sortColumn);\r\n            const column = this.getColumn(columnIndex);\r\n            if (column && column.sortable === false) {\r\n                return;\r\n            }\r\n            this.sortByColumn(columnIndex, value);\r\n        }\r\n    }\r\n\r\n    private sortByColumn(column: number, desc: boolean) {\r\n        const columnInfo = this.getColumn(column);\r\n        this.sort((x, y) => {\r\n            const cellX = x.cells[column];\r\n            const cellY = y.cells[column];\r\n            const dataX = this.getDataOf(cellX);\r\n            const dataY = this.getDataOf(cellY);\r\n            const result = columnInfo && columnInfo.sort ? columnInfo.sort(dataX, dataY, cellX, cellY) : dataX < dataY ? -1 : dataX > dataY ? 1 : 0;\r\n            return desc ? -result : result;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 根据指定的值排序。\r\n     * @param sorter 用于排序的函数。\r\n     */\r\n    sort(sorter?: (x: HTMLTableRowElement, y: HTMLTableRowElement) => number) {\r\n        const rows = Array.prototype.slice.call(this.rows);\r\n        rows.sort(sorter);\r\n        this.rows = rows;\r\n        this.emit(\"sort\");\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region 选中模式\r\n\r\n\r\n\r\n    // #endregion\r\n\r\n    // #region 编辑模式\r\n\r\n    /**\r\n     * 获取当前是否允许编辑。\r\n     */\r\n    editable: boolean;\r\n\r\n    /**\r\n     * 判断某个单元格是否正在编辑。\r\n     * @param cell 相关的单元格。\r\n     */\r\n    getEditing(cell: HTMLTableCellElement) {\r\n        return !!(<DataGridCell>cell).editor;\r\n    }\r\n\r\n    /**\r\n     * 设置某个单元格是否正在编辑。\r\n     * @param cell 相关的单元格。\r\n     * @param value 可编辑的状态。\r\n     * @param column 相关的列信息。\r\n     */\r\n    setEditing(cell: HTMLTableCellElement, value: boolean, column?: ColumnInfo<any>) {\r\n        if (this.editable === false || (value !== false) === this.getEditing(cell)) {\r\n            return;\r\n        }\r\n        if (!column) column = this.getColumn(cell.cellIndex);\r\n        if (column && column.editable === false) {\r\n            return;\r\n        }\r\n        if (value === false) {\r\n            dom.removeClass(cell, \"x-table-edit\");\r\n            const value = (<DataGridCell>cell).editor.value;\r\n            dom.remove((<DataGridCell>cell).editor.elem);\r\n            delete (<DataGridCell>cell).editor;\r\n            this.setDataOf(cell, value);\r\n            this.emit(\"endedit\", cell);\r\n        } else {\r\n            dom.addClass(cell, \"x-table-edit\");\r\n            const editor = this.getEditor(cell, column);\r\n            if (editor) {\r\n                editor.value = this.getDataOf(cell, column);\r\n                dom.setHtml(cell, \"\");\r\n                editor.appendTo(cell);\r\n                (<DataGridCell>cell).editor = editor;\r\n            }\r\n            this.emit(\"beginedit\", cell);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 当被子类重写时负责返回指定单元格的编辑器。\r\n     * @param cell 相关的单元格。\r\n     * @param column 相关的列信息。\r\n     */\r\n    protected getEditor(cell: HTMLTableCellElement, column: ColumnInfo<any>) {\r\n        if (column && column.editor) {\r\n            return column.editor(cell);\r\n        }\r\n        return new TextBox();\r\n    }\r\n\r\n    // /**\r\n    //  * 获取正在进行编辑模式的行。\r\n    //  */\r\n    // get editRow() {\r\n    //     return dom.find<HTMLTableRowElement>(\">.x-table-edit\", this.body);\r\n    // }\r\n\r\n    /**\r\n     * 进入编辑模式。\r\n     * @param row 相关的行号。如果未提供则所有行进入编辑模式。\r\n     * @param column 相关的列号。如果未提供则整行进入编辑模式。\r\n     */\r\n    beginEdit(row?: number | HTMLTableRowElement, column?: number) {\r\n        this.toggleEdit(row, column, true);\r\n    }\r\n\r\n    /**\r\n     * 退出编辑模式。\r\n     * @param row 相关的行号。如果未提供则所有行退出编辑模式。\r\n     * @param column 相关的列号。如果未提供则整行退出编辑模式。\r\n     */\r\n    endEdit(row?: number | HTMLTableRowElement, column?: number) {\r\n        this.toggleEdit(row, column, false);\r\n    }\r\n\r\n    /**\r\n     * 切换编辑模式。\r\n     * @param row 相关的行号。如果未提供则所有行退出编辑模式。\r\n     * @param column 相关的列号。如果未提供则整行退出编辑模式。\r\n     * @param value 设置模式。\r\n     */\r\n    toggleEdit(row?: number | HTMLTableRowElement, column?: number, value?: boolean) {\r\n        if (row === undefined) {\r\n            dom.toggleClass(this.elem, \"x-table-edit\", value);\r\n            const rowCount = this.rowCount;\r\n            for (let i = 0; i < rowCount; i++) {\r\n                this.toggleEdit(i, undefined, value);\r\n            }\r\n        } else {\r\n            if (typeof row === \"number\") {\r\n                console.assert(row >= 0 && row < this.rowCount);\r\n                row = this.rows[row];\r\n            }\r\n            if (column === undefined) {\r\n                dom.toggleClass(row, \"x-table-edit\", value);\r\n                const cellCount = row.cells.length;\r\n                for (let i = 0; i < cellCount; i++) {\r\n                    this.toggleEdit(row, i, value);\r\n                }\r\n            } else {\r\n                console.assert(column >= 0 && column < row.cells.length);\r\n                const cell = row.cells[column];\r\n                this.setEditing(cell, value === undefined ? !this.getEditing(cell) : value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断是否正在进行编辑模式。\r\n     */\r\n    isEditing(row?: number, column?: number) {\r\n        if (row === undefined) return dom.match(this.elem, \".x-table-edit\");\r\n        console.assert(row >= 0 && row < this.rowCount);\r\n        if (column === undefined) return dom.match(this.rows[row], \".x-table-edit\");\r\n        console.assert(column >= 0 && column < this.rows[row].cells.length);\r\n        return this.getEditing(this.rows[row].cells[column]);\r\n    }\r\n\r\n    // #endregion\r\n\r\n}\r\n\r\n/**\r\n * 表示数据表头的一个单元格。\r\n */\r\ninterface DataGridHeaderCell extends HTMLTableDataCellElement, HTMLTableHeaderCellElement {\r\n\r\n    /**\r\n     * 当前列的数据。\r\n     */\r\n    data?: ColumnInfo<any>;\r\n\r\n}\r\n\r\n/**\r\n * 表示数据表的一个单元格。\r\n */\r\ninterface DataGridCell extends HTMLTableDataCellElement, HTMLTableHeaderCellElement {\r\n\r\n    /**\r\n     * 和当前单元格绑定的数据。\r\n     */\r\n    editor?: DataGridCellEditor;\r\n\r\n}\r\n\r\n/**\r\n * 表示一个单元格编辑器。\r\n */\r\nexport interface DataGridCellEditor {\r\n\r\n    /**\r\n     * 获取当前编辑器的值。\r\n     */\r\n    value: any;\r\n\r\n    /**\r\n     * 获取当前编辑器的元素。\r\n     */\r\n    elem: HTMLElement;\r\n\r\n    /**\r\n     * 将当前编辑器添加到指定的容器。\r\n     */\r\n    appendTo(parent: HTMLElement);\r\n\r\n    /**\r\n     * 绑定 changing 事件。\r\n     */\r\n    on(event: \"changing\", handler: Function);\r\n\r\n}\r\n\r\n/**\r\n * 表示一个列信息。\r\n */\r\nexport interface ColumnInfo<T> {\r\n\r\n    /**\r\n     * 列名。\r\n     */\r\n    name?: string;\r\n\r\n    /**\r\n     * 列标题。\r\n     */\r\n    title?: string;\r\n\r\n    /**\r\n     * 是否隐藏列。\r\n     */\r\n    hidden?: boolean;\r\n\r\n    /**\r\n     * 是否允许基于当前列排序。\r\n     */\r\n    sortable?: boolean;\r\n\r\n    /**\r\n     * 是否允许编辑当前列。\r\n     */\r\n    editable?: boolean;\r\n\r\n    /**\r\n     * 用于将字符串转为当前列的函数。\r\n     */\r\n    parse?: (value: string, cell: HTMLTableCellElement) => T;\r\n\r\n    /**\r\n     * 用于格式化当前列为字符串的函数。\r\n     */\r\n    format?: (value: T, cell: HTMLTableCellElement) => string;\r\n\r\n    /**\r\n     * 用于筛选当前列的函数。\r\n     */\r\n    filter?: (value: T, cell: HTMLTableCellElement) => boolean;\r\n\r\n    /**\r\n     * 用于排序当前列的函数。\r\n     */\r\n    sort?: (x: T, y: T, cellX: HTMLTableCellElement, cellY: HTMLTableCellElement) => number;\r\n\r\n    /**\r\n     * 当前列在编辑模式的选择器。\r\n     */\r\n    editor?: ((cell: HTMLTableCellElement) => DataGridCellEditor);\r\n\r\n    /**\r\n     * 绑定的键名。\r\n     */\r\n    key?: string;\r\n\r\n}\r\n"],"mappings":";;IAKA;;OAEG;IACH,kBAAkC,SAAQ,iBAAO;QAEnC,MAAM;YACZ,MAAM,CAAC,gCAAK,KAAK,EAAC,gBAAgB,GAAO,CAAC;QAC9C,CAAC;KAEJ;IAND,+BAMC;IASD;;OAEG;IACH,kBAAkC,SAAQ,iBAAO;QAAjD;YAEI,eAAe;;YAEf;;eAEG;YACO,QAAG,GAAG,6DAA6D,CAAC;QAyzBlF,CAAC,AAAD;QAvzBI;;WAEA;QACU,IAAI;YACV,MAAM,EAAE,GAAG,IAAI,CAAC;YAChB,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,UAAS,CAAC,IAAI,EAAE,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/E,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,UAAS,CAAC,IAAI,EAAE,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtF,CAAC;QAES,aAAa,CAAC,MAA4B,EAAE,CAAQ;YAC1D,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,CAAC,CAAC;gBAC1B,MAAM,eAAe,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAC1C,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,KAAK,eAAe,CAAC,CAAC,CAAC;oBAC3C,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC;gBACnC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;gBAC3C,CAAC;YACL,CAAC;QACL,CAAC;QAES,cAAc,CAAC,GAAwB,EAAE,CAAQ;YACvD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;QACzB,CAAC;QAED,aAAa;QAEb,eAAe;QAEf;;WAEG;QACH,IAAI,IAAI,KAAK,MAAM,CAAC,GAAG,CAAC,KAAK,CAA0B,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;QAE7E;;WAEG;QACH,IAAI,MAAM,KAAK,MAAM,CAAC,GAAG,CAAC,IAAI,CAAsB,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;QAEvE;;WAEG;QACH,IAAI,WAAW,KAAK,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QAEtD;;WAEG;QACH,IAAI,OAAO;YACP,MAAM,MAAM,GAAsB,EAAE,CAAC;YACrC,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE,CAAC;gBACnC,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAClC,CAAC;YACD,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;QAED;;WAEG;QACH,IAAI,OAAO,CAAC,KAAK;YACb,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,GAAG,KAAK,CAAC,CAAC;QACrD,CAAC;QAED;;;;WAIG;QACH,SAAS,CAAI,KAAa;YACtB,MAAM,IAAI,GAAuB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YAC1D,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACP,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG;oBAC7B,IAAI,EAAE,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC;oBACvB,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC;oBACtC,MAAM,EAAE,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC;iBAC7B,CAAC,CAAC;YACP,CAAC;QACL,CAAC;QAED;;;;WAIG;QACH,SAAS,CAAI,KAAa,EAAE,KAAoB;YAC5C,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;QACvC,CAAC;QAED;;;;WAIG;QACH,YAAY,CAAI,KAAa,EAAE,KAAqB;YAChD,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;QACvC,CAAC;QAED;;;WAGG;QACH,SAAS,CAAI,KAAqB;YAC9B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QAC/C,CAAC;QAED;;;WAGG;QACH,YAAY,CAAC,KAAa;YACtB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAChC,CAAC;QAED;;;;WAIG;QACH,UAAU,CAAC,CAAS,EAAE,CAAS;YAC3B,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;YAC/C,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;YAC/C,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACV,MAAM,CAAC;YACX,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,GAAG,CAAC,CAAC;gBACZ,CAAC,GAAG,CAAC,CAAC;gBACN,CAAC,GAAG,CAAC,CAAC;YACV,CAAC;YACD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,MAAM,IAAI,GAAG,CAAC,uBAAC,gBAAgB;;gBAE3B,AAD2D;;gBAaI;;oBACnE,OAAO,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,WAAW,CAAC;;oBACR,gCAAE;;oBAGnC,uBAAC,gBAAgB;;wBAMmC,2CAAc;;wBAC5E,AADmF;;wBAM/E,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC,IAAI,CAAC;;wBAGvC,UAAU,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,IAAI,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC;;wBAG7D,AADoD;;wBAEhD,AAD2D;;wBAGvD,AADO;;wBAEH,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC;;wBAGvE,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,EAAE,SAAS,CAAC;;wBAM5E,YAAY,GAAG,IAAI;;wBAGnB,UAAU,GAAG,IAAI;;wBAMhB,uBAAE,OAAO,CAAC,MAAM,OAAC;;wBACtB,AAD6B;;;wBAIzB,AAD2D;;wBACP,kCAAK;;wBAAK,kCAAK;;wBACnD,uBAAC,YAAY;;4BAGzB,OAAO,GAAG,uBAAC,YAAY;;gCAEvB,AADI;;gCAEA,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC;;gCAIzB,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;;gCAGjB,AADiB;;gCAEb,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,CAAC;;gCAGpC,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,IAAI,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC;;gCAE1D,uBAAC,kBAAkB;;oCAEpB,AADI;;oCAEA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC;;oCAGb,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,SAAS,CAAC;;oCAOhD,2CAAc;;oCACnB,AAD0B;;oCAGtB,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;;oCAGlC,YAAY,GAAG,IAAI;;oCAMvB,AADe;;oCAEX,AAD2D;;oCAEvD,GAAG;;oCAEC,AADmE;;oCAG/D,IAAI,GAAG,KAAK;;oCAW5B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,CAAC;;oCAajD,AAAD;;oCAKK,AAAD;;oCAKH,AAAD;;oCAAiB,uBAAC,mBAAmB;;wCAM7C,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC;;wCAE/C,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;;wCASxE,uBAAC,CAAC;;4CACJ,AADsB;;4CAGlB,AADM;;4CAGF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;4CAYzC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC;;4CAS/B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,IAAI,EAAE,CAAC;;4CAUrC,AADmB;;4CAUnB,AADsB;;4CAatB,OAAO,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC;;4CACL,gCAAE;;4CAG/B,uBAAE,OAAO,CAAC,MAAM,OAAC;;4CAC/B,AADsC;;4CAEG,kCAAK;;4CAA4B,kCAAK;;4CAC7D,2CAAc;;4CAC5B,AADmC;;4CACtB,uBAAC,YAAY;;gDAAkB,kCAAK;;gDAC3C,uCAAU;;gDACZ,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;gDAK3C,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,CAAC;;gDAWzC,AAD2D;;gDAIvD,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC;;gDAUhE,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,IAAI,CAAC;;gDASzB,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,KAAK,CAAC;;gDAO1B,AADQ;;gDAGU,wCAAW;;gDACzB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;;gDAS/B,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;;gDAUlD,AADkC;;gDAalC,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC;;gDACV,uBAAE,IAAI,CAAC,IAAI,OAAC;;gDAUJ;;oDAC7C,AADqD;;oDAEjD,AADc;;oDAcuC;;wDACzD,AADiE;;wDAE7D,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,KAAK;;wDAKzB,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC;;wDAGlC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;;wDAgBb,AAAD;;wDAAgB,uBAAC,oBAAoB;;4DAMnD,AADmB;;4DASnB,OAAO,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC;;4DAElD,AAD0B;;4DAK1B,AADsC;;4DAKtC,GAAG,CAAC,WAAW,CAAC,UAAU,EAAE,mBAAmB,CAAC;;4DAWpD,AADY;;4DASZ,AADiB;;4DAGb,GAAG,CAAC,WAAW,CAAC,UAAU,EAAE,mBAAmB,EAAE,KAAK,CAAC;;4DAInD,AADsC;;4DAQ9C,AADiD;;4DAG7C,AADiB;;4DAKkF,qCAAS;;4DAUhH,AADuE;;4DA2BvE,AADoC;;4DAC1B,uBAAC,YAAY;;gEAS+C;;oEACtE,AAD8E;;oEAE1E,AADyE;;oEAKzE,AADsC;;oEAItC,GAAG,CAAC,WAAW,CAAC,IAAI,EAAE,cAAc,CAAC;;oEACtB,uBAAC,YAAY;;wEAChB,uBAAC,YAAY;;4EACjB,uBAAC,YAAY;;gFAIrB,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,cAAc,CAAC;;gFAG9B,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC;;gFAG1C,uBAAC,YAAY;;oFAWwC;;wFAC9D,AADsE;;wFAElE,AAD0B;;wFAUlC,yEAAyE;wFACzE,IAAI;wFAEJ;;;;2FAIG;wFACH,SAAS,CAAC,GAAG,GAAC,GAAE,MAAM,GAAG,mBAAmB,EAAE,MAAM,GAAC,GAAE,MAAM,CAAC;;wFAU1D,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC;;wFAUnC,AAD8E;;wFAE1E,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,cAAc,EAAE,KAAK,CAAC;;wFAE/B,wCAAW;;wFACzB,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC;;wFAGxC,AADI;;wFAEA,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC;;wFAI/C,GAAG,CAAC,WAAW,CAAC,GAAG,EAAE,cAAc,EAAE,KAAK,CAAC;;wFAEzB,yCAAY;;wFAC1B,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC;;wFAGlC,OAAO,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,IAAI,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC;;wFAWhE,AADsC;;wFAEP,uBAAE,IAAI,CAAC,QAAQ,OAAC;;wFAEV,uBAAE,IAAI,CAAC,IAAI,OAAC;;wFAarD;;2FAEG;wFACH,IAAI,GAAC,GAAE,UAAU,EAAK;;wFAStB;;2FAEG;wFACH,MAAM,GAAC,GAAE,kBAAkB;;wFAS3B;;2FAEG;wFACH,KAAK;;wFAsBkB,uBAAC,CAAC;;4FAEzB;;+FAEG;4FACH,IAAI,GAAC,GAAE,MAAM;qtCAqDjB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAC,AAAD;KAAA;IAh0BA,+BAg0BA"}