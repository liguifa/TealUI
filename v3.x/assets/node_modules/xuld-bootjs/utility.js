/**
 * @fileOverview Node.js 适配器，令代码可以同时在 node 或浏览器执行。
 * @author xuld
 */

var Path = typeof exports === 'object' ? require('path') : {

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    _normalizeArray: function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === '.') {
                parts.splice(i, 1);
            } else if (last === '..') {
                parts.splice(i, 1);
                up++;
            } else if (up) {
                parts.splice(i, 1);
                up--;
            }
        }

        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
            for (; up--; up) {
                parts.unshift('..');
            }
        }

        return parts;
    },

    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    _splitPath: function (filename) {
        return /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(filename).slice(1);
    },

    basePath: "",

    resolve: function () {
        var resolvedPath = '',
            resolvedAbsolute = false;

        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = (i >= 0) ? arguments[i] : Path.basePath;

            // Skip empty and invalid entries
            if (typeof path !== 'string') {
                throw new TypeError('Arguments to path.resolve must be strings');
            } else if (!path) {
                continue;
            }

            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charAt(0) === '/';
        }

        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)

        // Normalize the path
        resolvedPath = Path._normalizeArray(resolvedPath.split('/').filter(function (p) {
            return !!p;
        }), !resolvedAbsolute).join('/');

        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    },

    normalize: function (path) {

        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';

        // Normalize the path
        path = Path._normalizeArray(path.split('/').filter(function (p) {
            return !!p;
        }), !isAbsolute).join('/');

        if (!path && !isAbsolute) {
            path = '.';
        }
        if (path && trailingSlash) {
            path += '/';
        }

        return (isAbsolute ? '/' : '') + path.replace(/^(?:(\w{2,}:\/))([^\/])/, '$1/');
    },

    join: function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return Path.normalize(paths.filter(function (p, index) {
            if (typeof p !== 'string') {
                throw new TypeError('Arguments to path.join must be strings');
            }
            return p;
        }).join('/'));
    },

    relative: function (from, to) {

        from = Path.resolve(from);
        to = Path.resolve(to);

        function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
                if (arr[start] !== '') break;
            }

            var end = arr.length - 1;
            for (; end >= 0; end--) {
                if (arr[end] !== '') break;
            }

            if (start > end) return [];
            return arr.slice(start, end - start + 1);
        }

        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));

        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
            }
        }

        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push('..');
        }

        outputParts.push.apply(outputParts, toParts.slice(samePartsLength));

        return outputParts.join('/');
    },

    dirname: function (path) {
        var result = Path._splitPath(path),
            root = result[0],
            dir = result[1];

        if (!root && !dir) {
            // No dirname whatsoever
            return '.';
        }

        if (dir) {
            // It has a dirname, strip trailing slash
            dir = dir.substr(0, dir.length - 1);
        }

        return root + dir;
    },

    basename: function (path, ext) {
        var f = Path._splitPath(path)[2];
        // TODO: make this comparison case-insensitive on windows?
        if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
        }
        return f;
    },

    extname: function (path) {
        return Path._splitPath(path)[3];
    }

};

var Utility = typeof exports === 'object' ? exports : {};

Utility.extendIf = function (dest, src) {
    for (var key in src) {
        if (!(key in dest)) {
            dest[key] = src[key];
        }
    }
    return dest;
};

Utility.log = function (message) {
    if (typeof console !== 'undefined' && console.log) {
        console.log(message);
    }
};

Utility.error = function (message) {
    if (typeof console !== 'undefined' && console.error) {
        console.error(message);
    } else {
        this.log(message);
    }
};

Utility.warn = function (message) {
    if (typeof console !== 'undefined' && console.warn) {
        console.warn(message);
    } else {
        this.log(message);
    }
};

Utility.getExtension = Path.extname;

Utility.getRelativePath = function (from, to) {
    return Path.relative(/[\/\\]$/.test(from) ? from : Path.dirname(from), to).replace(/\\/g, '/');
};

/**
 * 解析相对路径。
 */
Utility.resolveRelativePath = function (baseFilePath, relativePath) {
    return Path.resolve(/[\/\\]$/.test(baseFilePath) ? baseFilePath : Path.dirname(baseFilePath), relativePath);
};

/**
 * 读取文件内容。
 */
Utility.readFile = typeof exports === "object" ? function (filePath, callback, encoding) {
    callback && callback(require("utilskit/io").readFile(filePath, encoding));
} : function (filePath, success, error, encoding) {
    var xhr = new XMLHttpRequest();
    xhr.open('get', filePath, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            xhr.onreadystatechange = null;
            var status = xhr.status;
            if ((status >= 200 && status < 300) || status == 304 || status == 1223) {
                callback && callback(xhr.responseText);
            } else {
                callback && callback(null, xhr.status + '-' + xhr.statusText);
            }
        }
    };
    xhr.send(null);
};

/**
 * 写入文件。
 */
Utility.writeFile = typeof exports === "object" ? function (filePath, content, encoding) {
    require("utilskit/io").writeFile(filePath, content, encoding);
} : function (filePath, content) {
    var dom = document.createElement('textarea');
    dom.title = filePath;
    dom.value = content;
    document.body.appendChild(dom);
};

/**
 * 复制文件。
 */
Utility.copyFile = typeof exports === "object" ? function (fromPath, toPath) {
    require("utilskit/io").copyFile(fromPath, toPath);
} : function (fromPath, toPath) {
    console.log('复制文件：' + fromPath + ' 到 ' + toPath);
};

/**
 * 压缩 js。
 */
Utility.compressJs = function (code) {

    if (typeof Compressor !== "function" || typeof parse !== "function") {
        if (typeof exports !== "object") {
            Utility.warn('暂时不支持压缩 js');
            return code;
        }
        parse = require('uglify-js').parse;
        Compressor = require('uglify-js').Compressor;
    }

    var ast = parse(code);
    ast.figure_out_scope();
    // https://github.com/mishoo/UglifyJS2#compressor-options

    var compressor = Compressor();

    compressor.options.warnings = false;

    ast.transform(compressor);
    ast.figure_out_scope();
    ast.compute_char_frequency();
    ast.mangle_names();
    return ast.print_to_string();
};

/**
 * 压缩 css。
 */
Utility.compressCss = function (code) {

    if (typeof cssmin !== "function") {
        if (typeof exports !== "object") {
            Utility.warn('暂时不支持压缩 css');
            return code;
        }
        cssmin = require('cssmin/cssmin');
    }

    return cssmin(code);
};

/**
 * 压缩 html。
 */
Utility.compressHtml = function (code) {
    if (window.console && console.warn) {
        Utility.warn('暂时不支持压缩 html');
    }
    return code;
};

/**
 * 获取现在时间表达式。
 */
Utility.getNow = function () {
    var d = new Date();
    d = [d.getFullYear(), '/', d.getMonth() + 1, '/', d.getDate(), ' ', d.getHours(), ':', d.getMinutes()];

    if (d[d.length - 1] < 10) {
        d[d.length - 1] = '0' + d[d.length - 1];
    }

    if (d[d.length - 3] < 10) {
        d[d.length - 3] = '0' + d[d.length - 3];
    }

    return d.join('');
};

/**
 * 解析宏。
 */
Utility.resolveMacro = function (content, defines) {

    var m = /^\/\/\/\s*#(\w+)(.*?)$/m;

    var r = [];

    while (content) {
        var value = m.exec(content);

        if (!value) {
            r.push([content, 0, 0]);
            break;
        }

        // 保留匹配部分的左边字符串。
        r.push([content.substring(0, value.index), 0, 0]);

        r.push(value);

        // 截取匹配部分的右边字符串。
        content = content.substring(value.index + value[0].length);
    }

    var codes = ['var $out="",$t;'];

    r.forEach(function (value, index) {

        if (!value[1]) {
            codes.push('$out+=$r[' + index + '][0];');
            return;
        }

        var v = value[2].trim();

        switch (value[1]) {

            case 'if':
                codes.push('if(' + v.replace(/\b([a-z_$]+)\b/ig, "$d.$1") + '){');
                break;

            case 'else':
                codes.push('}else{');
                break;

            case 'elsif':
                codes.push('}else if(' + v.replace(/\b([a-z_$]+)\b/g, "$d.$1") + '){');
                break;

            case 'endif':
            case 'endregion':
                codes.push('}');
                break;

            case 'define':
                var space = v.search(/\s/);
                if (space === -1) {
                    codes.push('if(!(' + v + ' in $d))$d.' + v + "=true;");
                } else {
                    codes.push('$d.' + v.substr(0, space) + "=" + v.substr(space) + ";");
                }
                break;

            case 'undef':
                codes.push('delete $d.' + v + ";");
                break;

            case 'ifdef':
                codes.push('if(' + v + ' in $d){');
                break;

            case 'ifndef':
                codes.push('if(!(' + v + ' in $d)){');
                break;

            case 'region':
                codes.push('if($d.' + v + ' !== false){');
                break;

            case 'rem':
                break;

            default:
                codes.push('$out+=$r[' + index + '][0];');
                break;
        }

    });

    codes.push('return $out;');

    var fn = new Function("$r", "$d", codes.join(''));

    return fn(r, defines);
};
